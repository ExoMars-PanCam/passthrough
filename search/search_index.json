{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Template-Driven PDS4 Data Product Generation Overview The Passthrough software library seeks to provide PDS4 data processors with an integrated solution for generating output labels based on declarative product type templates. It serves as a complementary counterpart to the PDS4 Tools read-in library, enabling processors to interact natively with the PDS4 format without the need for intermediary internal product representations or separate file formats. Passthrough is still in its initial development phase. Visit the About page for details on its status and timeline. Passthrough consists of a Python template handler , the Passthrough template language (PTL) specification , and a language logic extension API . Project documentation Tutorials - start here Hit the ground running with Passthrough, and learn how you can leverage type templates in your own mission's product processors. How-to guides Recipes addressing common use-cases and challenges you may encounter when designing templates and generating labels. Background Explanation of the key concepts behind Passthrough and its template language, and their roles in the product generation flow. Reference Technical description of the Python Template handler, the PTL syntax, and the core XPath extension functions.","title":"Home"},{"location":"#template-driven-pds4-data-product-generation","text":"","title":"Template-Driven PDS4 Data Product Generation"},{"location":"#overview","text":"The Passthrough software library seeks to provide PDS4 data processors with an integrated solution for generating output labels based on declarative product type templates. It serves as a complementary counterpart to the PDS4 Tools read-in library, enabling processors to interact natively with the PDS4 format without the need for intermediary internal product representations or separate file formats. Passthrough is still in its initial development phase. Visit the About page for details on its status and timeline. Passthrough consists of a Python template handler , the Passthrough template language (PTL) specification , and a language logic extension API .","title":"Overview"},{"location":"#project-documentation","text":"","title":"Project documentation"},{"location":"#tutorials-start-here","text":"Hit the ground running with Passthrough, and learn how you can leverage type templates in your own mission's product processors.","title":"Tutorials - start here"},{"location":"#how-to-guides","text":"Recipes addressing common use-cases and challenges you may encounter when designing templates and generating labels.","title":"How-to guides"},{"location":"#background","text":"Explanation of the key concepts behind Passthrough and its template language, and their roles in the product generation flow.","title":"Background"},{"location":"#reference","text":"Technical description of the Python Template handler, the PTL syntax, and the core XPath extension functions.","title":"Reference"},{"location":"about/","text":"About Project status and getting involved While major changes to the language specification are not foreseen, the template handler API and list of common extension functions are not yet stable. Additionally, the unit tests and CI setup need some love before Passthrough can be recommended for mission critical applications. A basic feature roadmap is kept in the project repository's readme , while the issues tell a somewhat finer-grained story. If you would like to get involved (great!), submitting an issue and introducing yourself is a good way to start things off. Feedback, suggestions and contributions from the community are welcome and appreciated. Acknowledgements Passthrough is developed by Ariel Ladegaard at Aberystwyth University, in support of the ESA /Roscosmos ExoMars 2022 mission's PanCam instrument. This work has been funded by the UK Space Agency, grant numbers ST/T000058/1 and ST/V002686/1. Special thanks are owed to Barry Whiteside ( MSSL ) and Komyo Furuya ( JR ) for providing valuable comments and feedback as early adopters of Passthrough. The project documentation has been written following Daniele Procida\u2019s excellent taxonomy of documentation . License The project is available as open source under the MIT license .","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"about/#project-status-and-getting-involved","text":"While major changes to the language specification are not foreseen, the template handler API and list of common extension functions are not yet stable. Additionally, the unit tests and CI setup need some love before Passthrough can be recommended for mission critical applications. A basic feature roadmap is kept in the project repository's readme , while the issues tell a somewhat finer-grained story. If you would like to get involved (great!), submitting an issue and introducing yourself is a good way to start things off. Feedback, suggestions and contributions from the community are welcome and appreciated.","title":"Project status and getting involved"},{"location":"about/#acknowledgements","text":"Passthrough is developed by Ariel Ladegaard at Aberystwyth University, in support of the ESA /Roscosmos ExoMars 2022 mission's PanCam instrument. This work has been funded by the UK Space Agency, grant numbers ST/T000058/1 and ST/V002686/1. Special thanks are owed to Barry Whiteside ( MSSL ) and Komyo Furuya ( JR ) for providing valuable comments and feedback as early adopters of Passthrough. The project documentation has been written following Daniele Procida\u2019s excellent taxonomy of documentation .","title":"Acknowledgements"},{"location":"about/#license","text":"The project is available as open source under the MIT license .","title":"License"},{"location":"background/","text":"Background To be written","title":"Background"},{"location":"background/#background","text":"To be written","title":"Background"},{"location":"background/template-processing/","text":"Template processing flow specifics The template handler is responsible for parsing and transforming a template into a partial label which is then handed over to be further populated by the invoking processor. In brief, the handler will perform the following (pre-processing) steps before handoff: parse the template elements depth-first in document order evaluate each element's declared and inherited properties to construct its effective state (and ensure its validity) construct and attach any duplicated subtrees ( multi or plural sources conditions) while visiting each element: execute fetch if present execute fill if present and not defer red record any defer red fill s or non- fetch required conditions for evaluation during post-processing After the invoking processor has populated the remaining elements of the partial label, control is handed back to the template handler as part of the label export process (i.e. Template.export(...) ), where the following (post-processing) steps occur: execute any recorded defer red fill s evaluate any non- fetch required conditions; prune eligible optional elements from the document tree ensure all remaining elements are populated if indicated: ensure the structure of the partial label has not been altered by the invoking processor after handoff (e.g. the processor hasn't slyly added in a class) remove unused namespace declarations (including the PT namespace) export the label","title":"Template processing"},{"location":"background/template-processing/#template-processing-flow-specifics","text":"The template handler is responsible for parsing and transforming a template into a partial label which is then handed over to be further populated by the invoking processor. In brief, the handler will perform the following (pre-processing) steps before handoff: parse the template elements depth-first in document order evaluate each element's declared and inherited properties to construct its effective state (and ensure its validity) construct and attach any duplicated subtrees ( multi or plural sources conditions) while visiting each element: execute fetch if present execute fill if present and not defer red record any defer red fill s or non- fetch required conditions for evaluation during post-processing After the invoking processor has populated the remaining elements of the partial label, control is handed back to the template handler as part of the label export process (i.e. Template.export(...) ), where the following (post-processing) steps occur: execute any recorded defer red fill s evaluate any non- fetch required conditions; prune eligible optional elements from the document tree ensure all remaining elements are populated if indicated: ensure the structure of the partial label has not been altered by the invoking processor after handoff (e.g. the processor hasn't slyly added in a class) remove unused namespace declarations (including the PT namespace) export the label","title":"Template processing flow specifics"},{"location":"get-started/installation/","text":"Installation Requirements Passthrough works with Python 3.6 or newer, and depends on the lxml and NumPy packages. Setting up a virtual environment If you want to follow along with the tutorial, we recommend creating a virtual environment for your project. We will be using venv , but you are of course free to use Poetry or similar if you want. Navigate to a fresh directory and execute: python3 -m venv env source env/bin/activate It is generally a good idea to ensure that pip is up to date: pip install --upgrade pip Installing Passthrough The Passthrough library lives on PyPI and can be installed with pip : pip install passthrough This will install the required dependencies and allow you to from passthrough import Template .","title":"Installation"},{"location":"get-started/installation/#installation","text":"","title":"Installation"},{"location":"get-started/installation/#requirements","text":"Passthrough works with Python 3.6 or newer, and depends on the lxml and NumPy packages.","title":"Requirements"},{"location":"get-started/installation/#setting-up-a-virtual-environment","text":"If you want to follow along with the tutorial, we recommend creating a virtual environment for your project. We will be using venv , but you are of course free to use Poetry or similar if you want. Navigate to a fresh directory and execute: python3 -m venv env source env/bin/activate It is generally a good idea to ensure that pip is up to date: pip install --upgrade pip","title":"Setting up a virtual environment"},{"location":"get-started/installation/#installing-passthrough","text":"The Passthrough library lives on PyPI and can be installed with pip : pip install passthrough This will install the required dependencies and allow you to from passthrough import Template .","title":"Installing Passthrough"},{"location":"get-started/next-steps/","text":"Next steps Please note that we're in the process of transitioning our documentation into this new format. We hope to have it completed by mid-August 2021; until then, some sections will be a little rough around the edges. The how-to area contains a collection of to-the-point guides on how to accomplish various template and processing goals with PT. Keen to understand the details of the Python API or the PTL XML markup? Head over to the reference area to learn more. To understand what exactly happens in PT's pre- and post-processing steps, there is a page that goes into some detail over in the background area . In time this area of the documentation will expand on the design decisions and rationale behind Passthrough.","title":"Next steps"},{"location":"get-started/next-steps/#next-steps","text":"Please note that we're in the process of transitioning our documentation into this new format. We hope to have it completed by mid-August 2021; until then, some sections will be a little rough around the edges. The how-to area contains a collection of to-the-point guides on how to accomplish various template and processing goals with PT. Keen to understand the details of the Python API or the PTL XML markup? Head over to the reference area to learn more. To understand what exactly happens in PT's pre- and post-processing steps, there is a page that goes into some detail over in the background area . In time this area of the documentation will expand on the design decisions and rationale behind Passthrough.","title":"Next steps"},{"location":"get-started/tutorial/","text":"Generating a product label The primer In this tutorial we will write a small processor which uses a simple PDS4 \"type template\" to generate data product labels. Our processor has been tasked with adding some missing label attributes 1 to a raw image product generated by a telemetry processor. Using Passthrough (PT), we can define a blueprint for how our modified output product should look - its type template - and use this to instantiate a \"partial label\" for the processor to populate. From here on we will assume that you have some familiarity with PDS4 labels, XML and Python, but the finer points will be explained as we go along. The input We have been provided with two sample input products which include img:filter_number - the number of the active filter as reported by our instrument. Our processor will be adding in the corresponding filter name, ID, bandwidth and centre wavelength attributes. As we are here only interested in a very small part of the input product's label (and PDS4 labels tend to get very long!), we will cut to the chase and hide the uninteresting bits behind <!-- ... --> comments. Please use your imagination to fill in the blanks. The sample input products differ only in the filter number they report; their structures are: sample_input_1.xml <Product_Observational xmlns= \"http://pds.nasa.gov/pds4/pds/v1\" xmlns:img= \"http://pds.nasa.gov/pds4/img/v1\" > <!-- ... --> <Observation_Area> <!-- ... --> <img:Imaging> <!-- ... --> <img:Optical_Filter> <img:filter_number> 2 </img:filter_number> </img:Optical_Filter> <!-- ... --> </img:Imaging> <!-- ... --> </Observation_Area> <!-- ... --> </Product_Observational> sample_input_2.xml <Product_Observational xmlns= \"http://pds.nasa.gov/pds4/pds/v1\" xmlns:img= \"http://pds.nasa.gov/pds4/img/v1\" > <!-- ... --> <Observation_Area> <!-- ... --> <img:Imaging> <!-- ... --> <img:Optical_Filter> <img:filter_number> 0 </img:filter_number> </img:Optical_Filter> <!-- ... --> </img:Imaging> <!-- ... --> </Observation_Area> <!-- ... --> </Product_Observational> The template Passthrough language (PTL for short) type templates look a lot like regular PDS4 labels, but with some extra XML markup thrown in. This markup takes the form of PT \"properties\" - XML attributes such as pt:fetch that direct Passthrough in how a template should be processed. The values of these XML attributes are (with the exception of pt:sources ) XPath expressions, which most prominently are used to imbue templates with conditional logic. To achieve our goals we have come up with the following template: template.xml <Product_Observational xmlns= \"http://pds.nasa.gov/pds4/pds/v1\" xmlns:img= \"http://pds.nasa.gov/pds4/img/v1\" xmlns:pt= \"https://github.com/ExoMars-PanCam/passthrough\" > <!-- ... --> <Observation_Area> <!-- ... --> <img:Imaging> <!-- ... --> <img:Optical_Filter pt:sources= \"input\" > <img:filter_number pt:fetch= \"true()\" /> <img:filter_name/> <img:filter_id pt:required= \"//img:Optical_Filter/img:filter_number != '0'\" /> <img:bandwidth unit= \"nm\" pt:required= \"//img:Optical_Filter/img:filter_number != '0'\" /> <img:center_filter_wavelength unit= \"nm\" pt:required= \"//img:Optical_Filter/img:filter_number != '0'\" /> </img:Optical_Filter> <!-- ... --> </img:Imaging> <!-- ... --> </Observation_Area> <!-- ... --> </Product_Observational> Attribute inheritance A key trait of PTL is the ability to pass through attribute values from an input product to the output product. Above, we are declaring the fetch property on img:filter_number , indicating that we want PT to retrieve its value from a source label. The source label in question is declared by the parent class' sources property to be the one given the nickname \"input\" - a moniker that our processor will associate with the input product during processing. Optional attributes Following on we have added in the img:filter_name attribute, and the absence of any markup here indicates that this attribute's value is expected to be populated by our processor. The last three attributes also should be filled in by our processor, but there's a catch: knowledge of our imager's operating modes tells us that it might report the filter number as 0 if a human has configured it incorrectly. In this case, our processor should just set the filter name to \"UNKNOWN\" and leave the remaining attributes out. We make this condition known in the template by declaring the required property, its value determined by an XPath expression which checks whether the img:filter_number of the \"input\" source product is equal to 0. If it is, The img:filter_id , img:bandwidth and img:center_filter_wavelength attributes can be omitted from the output product 2 . The processor Over in Python-land, our processor will make use of Passthrough's Template handler class to pre-process the template into a partial label that can be populated. processor.py from passthrough import Template def process ( input_path , output_name ): sources = { \"input\" : input_path } partial = Template ( \"./template.xml\" , sources , keep_template_comments = True ) # Determine the current product's filter number filter_number = partial . label . find ( \"//img:Optical_Filter/img:filter_number\" , partial . nsmap ) filter_number = int ( filter_number . text ) # Define the attribute values to populate for the range of filter numbers we expect filter_attributes = { \"filter_name\" : [ \"UNKNOWN\" , \"Broadband Red\" , \"Broadband Green\" , \"Broadband Blue\" , ], \"filter_id\" : [ None , \"C01\" , \"C02\" , \"C03\" ], \"bandwidth\" : [ None , \"100\" , \"80\" , \"120\" ], \"center_filter_wavelength\" : [ None , \"640\" , \"540\" , \"440\" ], } # Populate our attributes (but only if we actually have values for them) for attr_name , values in filter_attributes . items (): value = values [ filter_number ] if value is None : continue attr = partial . label . find ( f \"//img:Optical_Filter/img: { attr_name } \" , partial . nsmap ) attr . text = value # Write the completed label to disk partial . export ( \"./\" , output_name ) if __name__ == \"__main__\" : queue = { \"./sample_input_1.xml\" : \"result_1.xml\" , \"./sample_input_2.xml\" : \"result_2.xml\" , } for input_path , output_name in queue . items (): process ( input_path , output_name ) After importing the Template class, we make sure to associate the \"input\" moniker for pt:sources with the sample input product (specifically its path), before instantiating the partial label. With the partial label created we can read out its filter_number using an XPath query. This will allow us to select the correct values for the attributes we want to populate. After defining the range of values for our attributes (which in a more realistic scenario might have involved loading a dedicated calibration product), we use a loop to populate them, taking care to omit this step if we don't have a sensible value to populate them with. Product generation flow From the layout of the processor we can surmise that the product generation flow with passthrough follows three broad steps: gather the input product(s) and pre-process the template into a partial label object populate the remaining label attributes export the completed label, allowing PT to prune any unpopulated optional attributes and run its consistency checks. The results When we run our processor, we are presented with two resultant product labels, each corresponding to one of the sample input product labels: result_1.xml <?xml version='1.0' encoding='UTF-8'?> <Product_Observational xmlns= \"http://pds.nasa.gov/pds4/pds/v1\" xmlns:img= \"http://pds.nasa.gov/pds4/img/v1\" > <!-- ... --> <Observation_Area> <!-- ... --> <img:Imaging> <!-- ... --> <img:Optical_Filter> <img:filter_number> 2 </img:filter_number> <img:filter_name> Broadband Green </img:filter_name> <img:filter_id> C02 </img:filter_id> <img:bandwidth unit= \"nm\" > 80 </img:bandwidth> <img:center_filter_wavelength unit= \"nm\" > 540 </img:center_filter_wavelength> </img:Optical_Filter> <!-- ... --> </img:Imaging> <!-- ... --> </Observation_Area> <!-- ... --> </Product_Observational> result_2.xml <?xml version='1.0' encoding='UTF-8'?> <Product_Observational xmlns= \"http://pds.nasa.gov/pds4/pds/v1\" xmlns:img= \"http://pds.nasa.gov/pds4/img/v1\" > <!-- ... --> <Observation_Area> <!-- ... --> <img:Imaging> <!-- ... --> <img:Optical_Filter> <img:filter_number> 0 </img:filter_number> <img:filter_name> UNKNOWN </img:filter_name> </img:Optical_Filter> <!-- ... --> </img:Imaging> <!-- ... --> </Observation_Area> <!-- ... --> </Product_Observational> As intended, we see that result_2.xml , which was created with the 0-filter sample_product_2.xml as input, omits the ID, bandwidth and centre wavelength attributes as we intended. Success! The conclusion The scenario we have been working through in this tutorial of course only scratches the surface of what PT and PTL can do. Type templates can grapple with multiple simultaneous input products, automatically fill in attributes using XPath extension functions, and instantiate and manage blank payload data structures from the template's File_Area_* . But the usage pattern of working with Passthrough's Template class that we have established remains largely the same. In the next section we will look at where you can go from here to learn more about the individual components of Passthrough. In this documentation, the terms attribute and class always refer to PDS4 attribute and PDS4 class , respectively. In other words, XML elements . When there is a need to refer to XML attributes , this is spelled out. \u21a9 By default, all elements in a template are assumed to be required, i.e. present in the output product, unless explicitly declared otherwise. This follows the principle that a type template should directly reflect the structure of the product type it defines. The goal is to avoid surprises for users, and allow templates to act as formal definitions of product types and further as the interfaces between processors of a project's product pipeline. \u21a9","title":"Generating a product label"},{"location":"get-started/tutorial/#generating-a-product-label","text":"","title":"Generating a product label"},{"location":"get-started/tutorial/#the-primer","text":"In this tutorial we will write a small processor which uses a simple PDS4 \"type template\" to generate data product labels. Our processor has been tasked with adding some missing label attributes 1 to a raw image product generated by a telemetry processor. Using Passthrough (PT), we can define a blueprint for how our modified output product should look - its type template - and use this to instantiate a \"partial label\" for the processor to populate. From here on we will assume that you have some familiarity with PDS4 labels, XML and Python, but the finer points will be explained as we go along.","title":"The primer"},{"location":"get-started/tutorial/#the-input","text":"We have been provided with two sample input products which include img:filter_number - the number of the active filter as reported by our instrument. Our processor will be adding in the corresponding filter name, ID, bandwidth and centre wavelength attributes. As we are here only interested in a very small part of the input product's label (and PDS4 labels tend to get very long!), we will cut to the chase and hide the uninteresting bits behind <!-- ... --> comments. Please use your imagination to fill in the blanks. The sample input products differ only in the filter number they report; their structures are: sample_input_1.xml <Product_Observational xmlns= \"http://pds.nasa.gov/pds4/pds/v1\" xmlns:img= \"http://pds.nasa.gov/pds4/img/v1\" > <!-- ... --> <Observation_Area> <!-- ... --> <img:Imaging> <!-- ... --> <img:Optical_Filter> <img:filter_number> 2 </img:filter_number> </img:Optical_Filter> <!-- ... --> </img:Imaging> <!-- ... --> </Observation_Area> <!-- ... --> </Product_Observational> sample_input_2.xml <Product_Observational xmlns= \"http://pds.nasa.gov/pds4/pds/v1\" xmlns:img= \"http://pds.nasa.gov/pds4/img/v1\" > <!-- ... --> <Observation_Area> <!-- ... --> <img:Imaging> <!-- ... --> <img:Optical_Filter> <img:filter_number> 0 </img:filter_number> </img:Optical_Filter> <!-- ... --> </img:Imaging> <!-- ... --> </Observation_Area> <!-- ... --> </Product_Observational>","title":"The input"},{"location":"get-started/tutorial/#the-template","text":"Passthrough language (PTL for short) type templates look a lot like regular PDS4 labels, but with some extra XML markup thrown in. This markup takes the form of PT \"properties\" - XML attributes such as pt:fetch that direct Passthrough in how a template should be processed. The values of these XML attributes are (with the exception of pt:sources ) XPath expressions, which most prominently are used to imbue templates with conditional logic. To achieve our goals we have come up with the following template: template.xml <Product_Observational xmlns= \"http://pds.nasa.gov/pds4/pds/v1\" xmlns:img= \"http://pds.nasa.gov/pds4/img/v1\" xmlns:pt= \"https://github.com/ExoMars-PanCam/passthrough\" > <!-- ... --> <Observation_Area> <!-- ... --> <img:Imaging> <!-- ... --> <img:Optical_Filter pt:sources= \"input\" > <img:filter_number pt:fetch= \"true()\" /> <img:filter_name/> <img:filter_id pt:required= \"//img:Optical_Filter/img:filter_number != '0'\" /> <img:bandwidth unit= \"nm\" pt:required= \"//img:Optical_Filter/img:filter_number != '0'\" /> <img:center_filter_wavelength unit= \"nm\" pt:required= \"//img:Optical_Filter/img:filter_number != '0'\" /> </img:Optical_Filter> <!-- ... --> </img:Imaging> <!-- ... --> </Observation_Area> <!-- ... --> </Product_Observational>","title":"The template"},{"location":"get-started/tutorial/#attribute-inheritance","text":"A key trait of PTL is the ability to pass through attribute values from an input product to the output product. Above, we are declaring the fetch property on img:filter_number , indicating that we want PT to retrieve its value from a source label. The source label in question is declared by the parent class' sources property to be the one given the nickname \"input\" - a moniker that our processor will associate with the input product during processing.","title":"Attribute inheritance"},{"location":"get-started/tutorial/#optional-attributes","text":"Following on we have added in the img:filter_name attribute, and the absence of any markup here indicates that this attribute's value is expected to be populated by our processor. The last three attributes also should be filled in by our processor, but there's a catch: knowledge of our imager's operating modes tells us that it might report the filter number as 0 if a human has configured it incorrectly. In this case, our processor should just set the filter name to \"UNKNOWN\" and leave the remaining attributes out. We make this condition known in the template by declaring the required property, its value determined by an XPath expression which checks whether the img:filter_number of the \"input\" source product is equal to 0. If it is, The img:filter_id , img:bandwidth and img:center_filter_wavelength attributes can be omitted from the output product 2 .","title":"Optional attributes"},{"location":"get-started/tutorial/#the-processor","text":"Over in Python-land, our processor will make use of Passthrough's Template handler class to pre-process the template into a partial label that can be populated. processor.py from passthrough import Template def process ( input_path , output_name ): sources = { \"input\" : input_path } partial = Template ( \"./template.xml\" , sources , keep_template_comments = True ) # Determine the current product's filter number filter_number = partial . label . find ( \"//img:Optical_Filter/img:filter_number\" , partial . nsmap ) filter_number = int ( filter_number . text ) # Define the attribute values to populate for the range of filter numbers we expect filter_attributes = { \"filter_name\" : [ \"UNKNOWN\" , \"Broadband Red\" , \"Broadband Green\" , \"Broadband Blue\" , ], \"filter_id\" : [ None , \"C01\" , \"C02\" , \"C03\" ], \"bandwidth\" : [ None , \"100\" , \"80\" , \"120\" ], \"center_filter_wavelength\" : [ None , \"640\" , \"540\" , \"440\" ], } # Populate our attributes (but only if we actually have values for them) for attr_name , values in filter_attributes . items (): value = values [ filter_number ] if value is None : continue attr = partial . label . find ( f \"//img:Optical_Filter/img: { attr_name } \" , partial . nsmap ) attr . text = value # Write the completed label to disk partial . export ( \"./\" , output_name ) if __name__ == \"__main__\" : queue = { \"./sample_input_1.xml\" : \"result_1.xml\" , \"./sample_input_2.xml\" : \"result_2.xml\" , } for input_path , output_name in queue . items (): process ( input_path , output_name ) After importing the Template class, we make sure to associate the \"input\" moniker for pt:sources with the sample input product (specifically its path), before instantiating the partial label. With the partial label created we can read out its filter_number using an XPath query. This will allow us to select the correct values for the attributes we want to populate. After defining the range of values for our attributes (which in a more realistic scenario might have involved loading a dedicated calibration product), we use a loop to populate them, taking care to omit this step if we don't have a sensible value to populate them with.","title":"The processor"},{"location":"get-started/tutorial/#product-generation-flow","text":"From the layout of the processor we can surmise that the product generation flow with passthrough follows three broad steps: gather the input product(s) and pre-process the template into a partial label object populate the remaining label attributes export the completed label, allowing PT to prune any unpopulated optional attributes and run its consistency checks.","title":"Product generation flow"},{"location":"get-started/tutorial/#the-results","text":"When we run our processor, we are presented with two resultant product labels, each corresponding to one of the sample input product labels: result_1.xml <?xml version='1.0' encoding='UTF-8'?> <Product_Observational xmlns= \"http://pds.nasa.gov/pds4/pds/v1\" xmlns:img= \"http://pds.nasa.gov/pds4/img/v1\" > <!-- ... --> <Observation_Area> <!-- ... --> <img:Imaging> <!-- ... --> <img:Optical_Filter> <img:filter_number> 2 </img:filter_number> <img:filter_name> Broadband Green </img:filter_name> <img:filter_id> C02 </img:filter_id> <img:bandwidth unit= \"nm\" > 80 </img:bandwidth> <img:center_filter_wavelength unit= \"nm\" > 540 </img:center_filter_wavelength> </img:Optical_Filter> <!-- ... --> </img:Imaging> <!-- ... --> </Observation_Area> <!-- ... --> </Product_Observational> result_2.xml <?xml version='1.0' encoding='UTF-8'?> <Product_Observational xmlns= \"http://pds.nasa.gov/pds4/pds/v1\" xmlns:img= \"http://pds.nasa.gov/pds4/img/v1\" > <!-- ... --> <Observation_Area> <!-- ... --> <img:Imaging> <!-- ... --> <img:Optical_Filter> <img:filter_number> 0 </img:filter_number> <img:filter_name> UNKNOWN </img:filter_name> </img:Optical_Filter> <!-- ... --> </img:Imaging> <!-- ... --> </Observation_Area> <!-- ... --> </Product_Observational> As intended, we see that result_2.xml , which was created with the 0-filter sample_product_2.xml as input, omits the ID, bandwidth and centre wavelength attributes as we intended. Success!","title":"The results"},{"location":"get-started/tutorial/#the-conclusion","text":"The scenario we have been working through in this tutorial of course only scratches the surface of what PT and PTL can do. Type templates can grapple with multiple simultaneous input products, automatically fill in attributes using XPath extension functions, and instantiate and manage blank payload data structures from the template's File_Area_* . But the usage pattern of working with Passthrough's Template class that we have established remains largely the same. In the next section we will look at where you can go from here to learn more about the individual components of Passthrough. In this documentation, the terms attribute and class always refer to PDS4 attribute and PDS4 class , respectively. In other words, XML elements . When there is a need to refer to XML attributes , this is spelled out. \u21a9 By default, all elements in a template are assumed to be required, i.e. present in the output product, unless explicitly declared otherwise. This follows the principle that a type template should directly reflect the structure of the product type it defines. The goal is to avoid surprises for users, and allow templates to act as formal definitions of product types and further as the interfaces between processors of a project's product pipeline. \u21a9","title":"The conclusion"},{"location":"how-to/","text":"To be written","title":"How-to guides"},{"location":"how-to/fill-format/","text":"To be written","title":"Formatting strings with fill"},{"location":"how-to/multi-source-inheritance/","text":"To be written","title":"Inheriting from multiple sources"},{"location":"reference/","text":"Reference To be written","title":"Reference"},{"location":"reference/#reference","text":"To be written","title":"Reference"},{"location":"reference/extension-api/","text":"To be written","title":"Extension API"},{"location":"reference/python-api/","text":"Python API passthrough.Template The Template class manages the creation of a data product from a type template. After instantiation, the partial label is available through the label attribute. For convenience, the document root is also exposed, together with its nsmap (the namespace prefix->uri dictionary of the partial label). Attributes: Name Type Description label lxml.etree._ElementTree The partial label represented as an lxml element tree, which allows access to its classes and attributes via the XML DOM. root lxml.etree._Element The partial label's root element (e.g. Product_Observational ) nsmap dict The partial label's namespace map __init__ ( self , template , source_map , context_map = None , template_source_entry = True , keep_template_comments = False , skip_structure_check = False , quiet = False ) special Instantiate a partial label from the provided type template. Run the provided template through a series of pre-processing steps resulting in a partial label. Parameters: Name Type Description Default template Union[lxml.etree._ElementTree, pds4_tools.reader.general_objects.StructureList, pds4_tools.reader.label_objects.Label, pathlib.Path, str] LabelLike representation of the output product's type template (e.g. a string path to an XML file). required source_map Dict[str, Union[lxml.etree._ElementTree, pds4_tools.reader.general_objects.StructureList, pds4_tools.reader.label_objects.Label, pathlib.Path, str, Sequence[Union[lxml.etree._ElementTree, pds4_tools.reader.general_objects.StructureList, pds4_tools.reader.label_objects.Label, pathlib.Path, str]]]] A dictionary which maps string monikers used by the pt:sources property, to LabelLike source products. A single moniker can map to a single product or a list of products, and products can be referenced by multiple monikers. For instance: { \"input\" : \"input.xml\" , \"flat\" : \"flatfield.xml\" , \"processing_inputs\" : [ \"input.xml\" , \"flatfield.xml\" ], } required context_map Optional[dict] If called for by the template, a dictionary of key-value pairs which can be looked up using the pt:context() XPath extension function, for instance to automatically populate history entries with the processor's ID and version using the pt:fill property. None template_source_entry bool Add a \"template\"-> template mapping to source_map . Convenience option for self-referencing templates. True keep_template_comments bool If enabled, propagate XML comments from template to the exported output product. False skip_structure_check bool If enabled, share a few milliseconds off the export process (and some kilobytes of memory) by not sanity-checking the structure of the partial label to that of the original template . False quiet int If set to True, suppress Template log messages below logging.ERROR from propagating up the hierarchy. Alternatively, a numeric log level can be provided, which will be forwarded directly to the Template logger. False export ( self , directory , filename = None ) Export the partial label to the filesystem. Run the partial label through a series of post-processing steps before exporting the completed label to filename in `directory. If filename is not provided, the product ID part of the post-processed label's logical identifier (LID) will be used. Please note that this behaviour is likely to change in an upcoming release! Parameters: Name Type Description Default directory Union[pathlib.Path, str] Path to the desired output directory. required filename Optional[str] Filename override to use for the output label. None","title":"Python API"},{"location":"reference/python-api/#python-api","text":"","title":"Python API"},{"location":"reference/python-api/#passthroughtemplate","text":"The Template class manages the creation of a data product from a type template. After instantiation, the partial label is available through the label attribute. For convenience, the document root is also exposed, together with its nsmap (the namespace prefix->uri dictionary of the partial label). Attributes: Name Type Description label lxml.etree._ElementTree The partial label represented as an lxml element tree, which allows access to its classes and attributes via the XML DOM. root lxml.etree._Element The partial label's root element (e.g. Product_Observational ) nsmap dict The partial label's namespace map","title":"passthrough.Template"},{"location":"reference/python-api/#passthrough.template.Template.__init__","text":"Instantiate a partial label from the provided type template. Run the provided template through a series of pre-processing steps resulting in a partial label. Parameters: Name Type Description Default template Union[lxml.etree._ElementTree, pds4_tools.reader.general_objects.StructureList, pds4_tools.reader.label_objects.Label, pathlib.Path, str] LabelLike representation of the output product's type template (e.g. a string path to an XML file). required source_map Dict[str, Union[lxml.etree._ElementTree, pds4_tools.reader.general_objects.StructureList, pds4_tools.reader.label_objects.Label, pathlib.Path, str, Sequence[Union[lxml.etree._ElementTree, pds4_tools.reader.general_objects.StructureList, pds4_tools.reader.label_objects.Label, pathlib.Path, str]]]] A dictionary which maps string monikers used by the pt:sources property, to LabelLike source products. A single moniker can map to a single product or a list of products, and products can be referenced by multiple monikers. For instance: { \"input\" : \"input.xml\" , \"flat\" : \"flatfield.xml\" , \"processing_inputs\" : [ \"input.xml\" , \"flatfield.xml\" ], } required context_map Optional[dict] If called for by the template, a dictionary of key-value pairs which can be looked up using the pt:context() XPath extension function, for instance to automatically populate history entries with the processor's ID and version using the pt:fill property. None template_source_entry bool Add a \"template\"-> template mapping to source_map . Convenience option for self-referencing templates. True keep_template_comments bool If enabled, propagate XML comments from template to the exported output product. False skip_structure_check bool If enabled, share a few milliseconds off the export process (and some kilobytes of memory) by not sanity-checking the structure of the partial label to that of the original template . False quiet int If set to True, suppress Template log messages below logging.ERROR from propagating up the hierarchy. Alternatively, a numeric log level can be provided, which will be forwarded directly to the Template logger. False","title":"__init__()"},{"location":"reference/python-api/#passthrough.template.Template.export","text":"Export the partial label to the filesystem. Run the partial label through a series of post-processing steps before exporting the completed label to filename in `directory. If filename is not provided, the product ID part of the post-processed label's logical identifier (LID) will be used. Please note that this behaviour is likely to change in an upcoming release! Parameters: Name Type Description Default directory Union[pathlib.Path, str] Path to the desired output directory. required filename Optional[str] Filename override to use for the output label. None","title":"export()"},{"location":"reference/ptl/","text":"The Passthrough Template Language Please note This page needs to go on a diet. Some parts will likely be moved to the background area , in due course. To skip past the essay, navigate to the Passthrough properties subsection. The passthrough (PT) template language supports the effective generation of PDS4 (XML) data product labels. Distinct from many conventional template systems, PT is not designed to transform an input data structure directly into an output document. Rather, a template is pre-processed by the template handler into a partially populated label which is then handed off to the data product processor. The product processor is responsible for populating (most of) the remaining elements before handing back control to the template handler for post-processing and export. This usage pattern - simply referred to as \"fetch, fill - fill, export\" - has been deliberately chosen to leverage the label as its own data structure (i.e. the XML DOM), while addressing common needs when working with PDS4. As such, key features of the system include the ability to - pass through or redirect metadata entries (i.e. PDS4 classes and attributes) from input products (\"sources\") - work with multiple source labels and groups thereof - strictly specify the allowed permutations of the output label structure in a human friendly manner - abstract common operations (such as dealing with LIDs and datetimes) via built-in functions - define processor-side extensions To facilitate these features, a declarative approach is taken. PT templates foremost consist of a skeleton structure of the PDS4 classes and attributes that comprise a given data product type (e.g. a raw image, distinct from its downstream calibrated counterpart). In addition to these \"empty\" elements, XML attributes - not to be confused with PDS4 attributes (i.e. leaf nodes; here termed attributes ) - are added by the human template preparer to inform what pre- and post-processing shall be applied to specific elements and their descendants. A key principle of PT is that a template must fully specify the structure of the output product label it describes. In other words, a template shall act as the blueprint for its output product, and product processors are actively discouraged from amending the structural contents of the partial label generated from this template. However, tools are provided to allow different permutations of a label's structure to be described (i.e. some elements are only present under certain conditions), and repeating elements can be collapsed to increase readability of the template. A simple example excerpt of a template might look something like: <img:Exposure pt:fetch= \"true()\" pt:sources= \"primary\" > <img:exposure_duration_count/> <img:exposure_duration unit= \"s\" pt:fetch= \"false()\" /> <img:exposure_type pt:required= \"//psa:Sub-Instrument/psa:identifier != 'HRC'\" /> </img:Exposure> Here, the img:Exposure class is marked with pt:fetch=\"true()\" and pt:sources=\"primary\" to indicate that as part of pre-processing, its child attributes shall be populated with the values of the corresponding attributes from the primary source label; they will be passed through to the output label. As its name implies, PT emphasises facilitating this frequent tendency under PDS4 for downstream products to repeat metadata entries of their parents. While img:exposure_duration_count above will be populated from the primary source, img:exposure_duration is marked with pt:fetch=\"false()\" . This indicates that the template handler expects this attribute to instead be populated by the product processor (a calibration processor, in this scenario), and will verify this as part of post-processing. PT leverages the XML nature of PDS4 labels by making extensive use of XPath (and, as shown later, its ability to define custom extension functions). The img:exposure_type attribute in this example is absent in the source label if the data product belongs to a particular subinstrument. To inform the pre-processor of this, the element is marked as required on the condition that //psa:Sub-Instrument/psa:identifier != 'HRC' , an XPath boolean expression that compares the value of the relevant subinstrument attribute in the primary source label with the string literal \"HRC\". Hence the absence of img:exposure_type in the source will only trigger an error condition if HRC is not the active subinstrument.","title":"Type template language"},{"location":"reference/ptl/#the-passthrough-template-language","text":"Please note This page needs to go on a diet. Some parts will likely be moved to the background area , in due course. To skip past the essay, navigate to the Passthrough properties subsection. The passthrough (PT) template language supports the effective generation of PDS4 (XML) data product labels. Distinct from many conventional template systems, PT is not designed to transform an input data structure directly into an output document. Rather, a template is pre-processed by the template handler into a partially populated label which is then handed off to the data product processor. The product processor is responsible for populating (most of) the remaining elements before handing back control to the template handler for post-processing and export. This usage pattern - simply referred to as \"fetch, fill - fill, export\" - has been deliberately chosen to leverage the label as its own data structure (i.e. the XML DOM), while addressing common needs when working with PDS4. As such, key features of the system include the ability to - pass through or redirect metadata entries (i.e. PDS4 classes and attributes) from input products (\"sources\") - work with multiple source labels and groups thereof - strictly specify the allowed permutations of the output label structure in a human friendly manner - abstract common operations (such as dealing with LIDs and datetimes) via built-in functions - define processor-side extensions To facilitate these features, a declarative approach is taken. PT templates foremost consist of a skeleton structure of the PDS4 classes and attributes that comprise a given data product type (e.g. a raw image, distinct from its downstream calibrated counterpart). In addition to these \"empty\" elements, XML attributes - not to be confused with PDS4 attributes (i.e. leaf nodes; here termed attributes ) - are added by the human template preparer to inform what pre- and post-processing shall be applied to specific elements and their descendants. A key principle of PT is that a template must fully specify the structure of the output product label it describes. In other words, a template shall act as the blueprint for its output product, and product processors are actively discouraged from amending the structural contents of the partial label generated from this template. However, tools are provided to allow different permutations of a label's structure to be described (i.e. some elements are only present under certain conditions), and repeating elements can be collapsed to increase readability of the template. A simple example excerpt of a template might look something like: <img:Exposure pt:fetch= \"true()\" pt:sources= \"primary\" > <img:exposure_duration_count/> <img:exposure_duration unit= \"s\" pt:fetch= \"false()\" /> <img:exposure_type pt:required= \"//psa:Sub-Instrument/psa:identifier != 'HRC'\" /> </img:Exposure> Here, the img:Exposure class is marked with pt:fetch=\"true()\" and pt:sources=\"primary\" to indicate that as part of pre-processing, its child attributes shall be populated with the values of the corresponding attributes from the primary source label; they will be passed through to the output label. As its name implies, PT emphasises facilitating this frequent tendency under PDS4 for downstream products to repeat metadata entries of their parents. While img:exposure_duration_count above will be populated from the primary source, img:exposure_duration is marked with pt:fetch=\"false()\" . This indicates that the template handler expects this attribute to instead be populated by the product processor (a calibration processor, in this scenario), and will verify this as part of post-processing. PT leverages the XML nature of PDS4 labels by making extensive use of XPath (and, as shown later, its ability to define custom extension functions). The img:exposure_type attribute in this example is absent in the source label if the data product belongs to a particular subinstrument. To inform the pre-processor of this, the element is marked as required on the condition that //psa:Sub-Instrument/psa:identifier != 'HRC' , an XPath boolean expression that compares the value of the relevant subinstrument attribute in the primary source label with the string literal \"HRC\". Hence the absence of img:exposure_type in the source will only trigger an error condition if HRC is not the active subinstrument.","title":"The Passthrough Template Language"},{"location":"reference/ptl/xpath/","text":"XPath expressions Please note This page is a stub and will be updated in due course, in particular with the list of common XPath extension functions provided by PT. PT property expressions make prolific use of XPath. The reference Python implementation of PT is based on lxml , which supports the XPath 1.0 feature set. Prefixes Although labels conventionally make the main PDS4 data dictionary schema the default (prefix-less) namespace, XPath does not have a notion of a default namespace. PT will therefore map the default namespace of the active source (i.e. the XPath evaluation context) to the pds prefix. This means that property XPath expressions are required to prefix elements in the default namespace with pds , e.g. //pds:Time_Coordinates/pds:start_date_time . Extension functions XPath extensions are functions made available within XPath expressions either by PT itself (to address common needs) or a specific mission or instrument team. Such functions are placed under their own function namespace to differentiate them from the standard array of XPath functions, and from other extension groups. The common set of functions provided by Passthrough can be found under the pt namespace.","title":"XPath expressions"},{"location":"reference/ptl/xpath/#xpath-expressions","text":"Please note This page is a stub and will be updated in due course, in particular with the list of common XPath extension functions provided by PT. PT property expressions make prolific use of XPath. The reference Python implementation of PT is based on lxml , which supports the XPath 1.0 feature set.","title":"XPath expressions"},{"location":"reference/ptl/xpath/#prefixes","text":"Although labels conventionally make the main PDS4 data dictionary schema the default (prefix-less) namespace, XPath does not have a notion of a default namespace. PT will therefore map the default namespace of the active source (i.e. the XPath evaluation context) to the pds prefix. This means that property XPath expressions are required to prefix elements in the default namespace with pds , e.g. //pds:Time_Coordinates/pds:start_date_time .","title":"Prefixes"},{"location":"reference/ptl/xpath/#extension-functions","text":"XPath extensions are functions made available within XPath expressions either by PT itself (to address common needs) or a specific mission or instrument team. Such functions are placed under their own function namespace to differentiate them from the standard array of XPath functions, and from other extension groups. The common set of functions provided by Passthrough can be found under the pt namespace.","title":"Extension functions"},{"location":"reference/ptl/properties/","text":"Passthrough properties The term element is used as a shorthand for XML element . It is sometimes useful to distinguish between leaf node and non-leaf node elements, which in PDS4 terms are referred to as attributes and classes , respectively. The term attribute is therefore used as a shorthand for PDS4 attribute ; XML attribute is always spelled out. The PT template language is based around assigning properties to elements of a template. These properties consist of a single keyword - expression pair and are declared on elements in the template via XML attributes under the PT namespace, i.e. pt:keyword=\"expression\" . The below table summarises the key characteristics of the properties that the language currently defines. Their individual usage patterns are described further in the next section. Keyword Expression type Evaluated type Default Inherited sources string (key) Sources (one or more labels) None yes fetch XPath boolean False yes multi XPath boolean or integer False no required XPath boolean True yes* fill XPath string** None no defer XPath boolean False no * terms and conditions apply; further details below. ** fill expressions do not have to result in a string directly; see the relevant section below. Initially an element will be assigned the default value of each of the PT properties. Unless a property is explicitly declared on a given element via an XML attribute, for some it will be inherited from the element's parent. Certain properties are only applicable to leaf nodes (attributes), while others modify the evaluation of another property. During pre-processing of a template, the effective values of the PT properties of each element will be derived. Together these constitute an element's state, which the pre-processor will check for consistency.","title":"Passthrough properties"},{"location":"reference/ptl/properties/#passthrough-properties","text":"The term element is used as a shorthand for XML element . It is sometimes useful to distinguish between leaf node and non-leaf node elements, which in PDS4 terms are referred to as attributes and classes , respectively. The term attribute is therefore used as a shorthand for PDS4 attribute ; XML attribute is always spelled out. The PT template language is based around assigning properties to elements of a template. These properties consist of a single keyword - expression pair and are declared on elements in the template via XML attributes under the PT namespace, i.e. pt:keyword=\"expression\" . The below table summarises the key characteristics of the properties that the language currently defines. Their individual usage patterns are described further in the next section. Keyword Expression type Evaluated type Default Inherited sources string (key) Sources (one or more labels) None yes fetch XPath boolean False yes multi XPath boolean or integer False no required XPath boolean True yes* fill XPath string** None no defer XPath boolean False no * terms and conditions apply; further details below. ** fill expressions do not have to result in a string directly; see the relevant section below. Initially an element will be assigned the default value of each of the PT properties. Unless a property is explicitly declared on a given element via an XML attribute, for some it will be inherited from the element's parent. Certain properties are only applicable to leaf nodes (attributes), while others modify the evaluation of another property. During pre-processing of a template, the effective values of the PT properties of each element will be derived. Together these constitute an element's state, which the pre-processor will check for consistency.","title":"Passthrough properties"},{"location":"reference/ptl/properties/defer/","text":"pt:defer The defer property amounts to a binary flag that dictates whether an accompanying fill property should be evaluated during the pre-processing (False) or the post-processing (True) stage (i.e. before or after the product processor has performed element population).","title":"\u2023 defer"},{"location":"reference/ptl/properties/defer/#ptdefer","text":"The defer property amounts to a binary flag that dictates whether an accompanying fill property should be evaluated during the pre-processing (False) or the post-processing (True) stage (i.e. before or after the product processor has performed element population).","title":"pt:defer"},{"location":"reference/ptl/properties/fetch/","text":"pt:fetch The fetch property signals whether an element (or its attribute descendants, if the element is a class) should have its value (here: the XML element's text and XML attributes) populated by the corresponding source element. Given that the fetch property is inheritable, declaring it on a class conveys the intent that its entire subtree should be fetch ed, except where a descendant element declares otherwise. The definition of \"corresponding source element\" in the context of fetch is the element within the active source label whose path matches that of the given element in the template. Specifically, the path used follows the ElementPath standard, which ensures that the fully qualified tags of the element and its ancestors are taken into account rather than just their document order positions (commonly seen in XPath derived paths). It is not currently possible for fetch to target a specific instance of a plural element; the n-th instance of a template element will match the n-th instance of the corresponding source element. However, it is possible to duplicate a singular template element's subtree for each matched source instance, using the multi property.","title":"\u2023 fetch"},{"location":"reference/ptl/properties/fetch/#ptfetch","text":"The fetch property signals whether an element (or its attribute descendants, if the element is a class) should have its value (here: the XML element's text and XML attributes) populated by the corresponding source element. Given that the fetch property is inheritable, declaring it on a class conveys the intent that its entire subtree should be fetch ed, except where a descendant element declares otherwise. The definition of \"corresponding source element\" in the context of fetch is the element within the active source label whose path matches that of the given element in the template. Specifically, the path used follows the ElementPath standard, which ensures that the fully qualified tags of the element and its ancestors are taken into account rather than just their document order positions (commonly seen in XPath derived paths). It is not currently possible for fetch to target a specific instance of a plural element; the n-th instance of a template element will match the n-th instance of the corresponding source element. However, it is possible to duplicate a singular template element's subtree for each matched source instance, using the multi property.","title":"pt:fetch"},{"location":"reference/ptl/properties/fill/","text":"pt:fill The fill property can only be declared on attributes, and will set (or replace) the text contents of the attribute with the result of its XPath expression. This functionality is commonly used to either modify a fetch ed attribute, or set an attribute's value from a a non-corresponding source element (i.e. an attribute in the source which has a different path than the template attribute). An important difference from the behaviour of fetch is that fill will only set the text field of its target attribute - XML attributes (e.g. unit ) are not carried over. Accepted types Although ultimately a string is required, fill 's XPath evaluator will in practice accept a range of different resultant types from its property expression: - Element (the element's text field will be used) - floats (note that working with integers in XPath is a bit cumbersome, e.g. the expression 1 + 1 evaluates to the float 2.0 . If integer representation is needed the builtin string function can be useful. e.g. string(1.0 + 1) evaluates to the int 2 ) - booleans (these will be \"PDS-ified\" to the strings true and false ) Non-corresponding source elements Revisiting our earlier example from the Source groups section, we see that there are two attributes that need to be populated for each source: lid_reference and emrsp_rm:operational_vid . The values for both can be found in statically known attributes in the source, but we cannot fetch them as they do not have the same paths as the target template attributes. We could leave their population up to the product processor, but the \"boiler plate\" nature of the copy-paste operations involved makes fill ing an attractive alternative, which also has the added benefit of making this part of the template self-documenting: <emrsp_rm:Processing_Inputs pt:fetch= \"false()\" > <emrsp_rm:Processing_Input_Identification pt:sources= \"all\" > <!-- one entry each for all source products --> <emrsp_rm:type> PDS product </emrsp_rm:type> <emrsp_rm:Operational_Reference> <lid_reference pt:fill= \"//pds:Identification_Area/pds:logical_identifier/text()\" /> <emrsp_rm:operational_vid pt:fill= \"//emrsp_rm:Mission_Product/emrsp_rm:operational_vid\" /> </emrsp_rm:Operational_Reference> </emrsp_rm:Processing_Input_Identification> </emrsp_rm:Processing_Inputs> In light of the above discussion on accepted types, the expression used for lid_reference could be simplified to omit the trailing /text() subexpression. Modifying a fetched value In the context of a fetch , fill is evaluated last, allowing its expression to make use of an attribute's fetch ed value via introspection: <emrsp_rm:Mission_Product pt:fetch= \"true()\" pt:sources= \"primary\" > ... <emrsp_rm:operatyonal_vid pt:fill= \"string(pt:self() + 1)\" /> <!-- string to ensure int result and not default float --> ... </emrsp_rm:Mission_Product> In this example we are producing an updated version of an existing product, and therefore wish to ensure that its version identifier is incremented. This is achieved by letting the fill expression read in the post- fetch value of the emrsp_rm:operatyonal_vid attribute via the pt:self() builtin extension function (detailed further in the XPath section). Separation of concerns Note that there is nothing stopping one from \"putting the processor in the template\" to some extent. For instance, if a calibrated attribute needs to be populated based on a static modification of a source attribute (e.g. exposure time from exposure ticks), this could be addressed by a fill expression. However, this approach is generally considered bad practice from a separation of concerns perspective. There is a grey line to be drawn between boiler plate operations and processing, and this line runs somewhere in the vicinity of the following scheme: <Time_Coordinates pt:fetch= \"true()\" pt:sources= \"primary\" > <start_date_time/> <!-- will be retrieved from the primary input label --> <stop_date_time pt:fetch= \"false()\" pt:sources= \"template\" pt:defer= \"true()\" pt:fill= \"pt:datetime_inc(//pds:Time_Coordinates/pds:start_date_time, //img:Exposure/img:exposure_duration)\" /> </Time_Coordinates> In keeping with the theme of a calibration processor, the above example shows how a stop_date_time can be expressed in the template using a defer red fill expression (that is, evaluated during post-processing) employing an XPath extension function which increments the fetch ed observation start time by the product processor-populated calibrated exposure duration. This application might be considered to be within the remit of the template because it deals with the minutiae of PDS4 datetime formatting - functionality that arguably is better suited to being encapsulated in a PT extension function than duplicated across processors.","title":"\u2023 fill"},{"location":"reference/ptl/properties/fill/#ptfill","text":"The fill property can only be declared on attributes, and will set (or replace) the text contents of the attribute with the result of its XPath expression. This functionality is commonly used to either modify a fetch ed attribute, or set an attribute's value from a a non-corresponding source element (i.e. an attribute in the source which has a different path than the template attribute). An important difference from the behaviour of fetch is that fill will only set the text field of its target attribute - XML attributes (e.g. unit ) are not carried over.","title":"pt:fill"},{"location":"reference/ptl/properties/fill/#accepted-types","text":"Although ultimately a string is required, fill 's XPath evaluator will in practice accept a range of different resultant types from its property expression: - Element (the element's text field will be used) - floats (note that working with integers in XPath is a bit cumbersome, e.g. the expression 1 + 1 evaluates to the float 2.0 . If integer representation is needed the builtin string function can be useful. e.g. string(1.0 + 1) evaluates to the int 2 ) - booleans (these will be \"PDS-ified\" to the strings true and false )","title":"Accepted types"},{"location":"reference/ptl/properties/fill/#non-corresponding-source-elements","text":"Revisiting our earlier example from the Source groups section, we see that there are two attributes that need to be populated for each source: lid_reference and emrsp_rm:operational_vid . The values for both can be found in statically known attributes in the source, but we cannot fetch them as they do not have the same paths as the target template attributes. We could leave their population up to the product processor, but the \"boiler plate\" nature of the copy-paste operations involved makes fill ing an attractive alternative, which also has the added benefit of making this part of the template self-documenting: <emrsp_rm:Processing_Inputs pt:fetch= \"false()\" > <emrsp_rm:Processing_Input_Identification pt:sources= \"all\" > <!-- one entry each for all source products --> <emrsp_rm:type> PDS product </emrsp_rm:type> <emrsp_rm:Operational_Reference> <lid_reference pt:fill= \"//pds:Identification_Area/pds:logical_identifier/text()\" /> <emrsp_rm:operational_vid pt:fill= \"//emrsp_rm:Mission_Product/emrsp_rm:operational_vid\" /> </emrsp_rm:Operational_Reference> </emrsp_rm:Processing_Input_Identification> </emrsp_rm:Processing_Inputs> In light of the above discussion on accepted types, the expression used for lid_reference could be simplified to omit the trailing /text() subexpression.","title":"Non-corresponding source elements"},{"location":"reference/ptl/properties/fill/#modifying-a-fetched-value","text":"In the context of a fetch , fill is evaluated last, allowing its expression to make use of an attribute's fetch ed value via introspection: <emrsp_rm:Mission_Product pt:fetch= \"true()\" pt:sources= \"primary\" > ... <emrsp_rm:operatyonal_vid pt:fill= \"string(pt:self() + 1)\" /> <!-- string to ensure int result and not default float --> ... </emrsp_rm:Mission_Product> In this example we are producing an updated version of an existing product, and therefore wish to ensure that its version identifier is incremented. This is achieved by letting the fill expression read in the post- fetch value of the emrsp_rm:operatyonal_vid attribute via the pt:self() builtin extension function (detailed further in the XPath section).","title":"Modifying a fetched value"},{"location":"reference/ptl/properties/fill/#separation-of-concerns","text":"Note that there is nothing stopping one from \"putting the processor in the template\" to some extent. For instance, if a calibrated attribute needs to be populated based on a static modification of a source attribute (e.g. exposure time from exposure ticks), this could be addressed by a fill expression. However, this approach is generally considered bad practice from a separation of concerns perspective. There is a grey line to be drawn between boiler plate operations and processing, and this line runs somewhere in the vicinity of the following scheme: <Time_Coordinates pt:fetch= \"true()\" pt:sources= \"primary\" > <start_date_time/> <!-- will be retrieved from the primary input label --> <stop_date_time pt:fetch= \"false()\" pt:sources= \"template\" pt:defer= \"true()\" pt:fill= \"pt:datetime_inc(//pds:Time_Coordinates/pds:start_date_time, //img:Exposure/img:exposure_duration)\" /> </Time_Coordinates> In keeping with the theme of a calibration processor, the above example shows how a stop_date_time can be expressed in the template using a defer red fill expression (that is, evaluated during post-processing) employing an XPath extension function which increments the fetch ed observation start time by the product processor-populated calibrated exposure duration. This application might be considered to be within the remit of the template because it deals with the minutiae of PDS4 datetime formatting - functionality that arguably is better suited to being encapsulated in a PT extension function than duplicated across processors.","title":"Separation of concerns"},{"location":"reference/ptl/properties/multi/","text":"pt:multi In a similar fashion to required , the multi property functions slightly differently depending on whether it is declared within a fetch context or not. When fetching In this context multi is used to signal whether the pre-processor should expect to find multiple instances of an element in the active source, and optionally how many. An evaluated value of True (as achieved with any boolean XPath expression such as true() or even 1 = 1 ) will duplicate the template element for each matched instance in the active source. If instead the expression evaluates to an integer, N , the effect is functionally equivalent to if the element (subtree) was repeated N times in the template instead, with the exception that the pre-processor will raise an error if the number of matched source instances is not equal to N . <geom:Motion_Counter pt:fetch= \"true()\" pt:sources= \"primary\" > <geom:name/> <local_identifier/> <geom:Motion_Counter_Index pt:multi= \"12\" > <geom:index_id/> <geom:index_value_number/> </geom:Motion_Counter_Index> </geom:Motion_Counter> Here, setting multi to 12 signals that we expect the pre-processor to find exactly 12 instances of geom:Motion_Counter_Index in the active source label. Specifying the cardinality is not strictly necessary, but in this example we know that the motion counter has exactly 12 indices, which we wish to express to increase the descriptiveness of the template and enable the additional consistency checks. When not fetching Outside the fetch context, the multi property can be used for convenience to collapse repeating (identical) elements in the template into a single entry. In this mode the property expression must evaluate to an integer (as a value of True would not be very helpful), which indicates the total number of element instances that will be made available by the pre-processor.","title":"\u2023 multi"},{"location":"reference/ptl/properties/multi/#ptmulti","text":"In a similar fashion to required , the multi property functions slightly differently depending on whether it is declared within a fetch context or not.","title":"pt:multi"},{"location":"reference/ptl/properties/multi/#when-fetching","text":"In this context multi is used to signal whether the pre-processor should expect to find multiple instances of an element in the active source, and optionally how many. An evaluated value of True (as achieved with any boolean XPath expression such as true() or even 1 = 1 ) will duplicate the template element for each matched instance in the active source. If instead the expression evaluates to an integer, N , the effect is functionally equivalent to if the element (subtree) was repeated N times in the template instead, with the exception that the pre-processor will raise an error if the number of matched source instances is not equal to N . <geom:Motion_Counter pt:fetch= \"true()\" pt:sources= \"primary\" > <geom:name/> <local_identifier/> <geom:Motion_Counter_Index pt:multi= \"12\" > <geom:index_id/> <geom:index_value_number/> </geom:Motion_Counter_Index> </geom:Motion_Counter> Here, setting multi to 12 signals that we expect the pre-processor to find exactly 12 instances of geom:Motion_Counter_Index in the active source label. Specifying the cardinality is not strictly necessary, but in this example we know that the motion counter has exactly 12 indices, which we wish to express to increase the descriptiveness of the template and enable the additional consistency checks.","title":"When fetching"},{"location":"reference/ptl/properties/multi/#when-not-fetching","text":"Outside the fetch context, the multi property can be used for convenience to collapse repeating (identical) elements in the template into a single entry. In this mode the property expression must evaluate to an integer (as a value of True would not be very helpful), which indicates the total number of element instances that will be made available by the pre-processor.","title":"When not fetching"},{"location":"reference/ptl/properties/required/","text":"pt:required The required property evaluates to a boolean flag which has similar but distinct consequences depending on whether fetch is in effect. An element whose required property is evaluated to be False is referred to as an optional element, while one whose property is evaluated to True is referred to as a required element. When fetching In the context of a fetch , required is used to determine how to handle missing corresponding source elements. If the property evaluates to True this triggers an error condition, while if it instead evaluates to False the element (subtree) will simply be omitted from the output product. A common usage example of this feature can be seen in the Overview section above. When not fetching In the non- fetch ing context, required signals whether an element left empty by the product processor (and/or any fill evaluations) should be treated as an error condition (True), or if the element (subtree) should be pruned from the output product (False). Elements that are \"nilled out\", i.e. that contain the attribute xsi:nil=\"true\" , are not considered to be empty by PT. An important detail in this context is that the evaluation of required 's XPath expression is deferred until the post-processing stage. Thus, the expression can inspect the template label as populated by the product processor (which at that point might contain relevant information about what processing has been performed) to determine whether the given element is required to be present in the output label. For example, <img_surface:mesh_id pt:fetch= \"false()\" pt:required= \"//ex:Some_Indicative/ex:attribute == 'meshtype'\" pt:sources= \"template\" /> can be read as: the img_surface:mesh_id attribute will be pruned by the post-processor if it is empty and ex:Some_Indicative/ex:attribute in the output label (conventionally set as the active source via the template source map key) is not equal to \"meshtype\". When a class is evaluated to be optional, then for the purposes of deciding whether it should be pruned, the class is considered empty if any of its children are empty. Therefore, in the case of <emrsp_rm_pan:ISEM_Footprint pt:fetch= \"false()\" pt:required= \"false()\" > <description> Estimated location of the ISEM footprint and 1 sigma radius, based on the focus distance </description> <emrsp_rm_pan:x/> <emrsp_rm_pan:y/> <emrsp_rm_pan:radius/> </emrsp_rm_pan:ISEM_Footprint> the emrsp_rm_pan:ISEM_Footprint class will be pruned by the post-processor if any of x , y or radius is empty. The required property is in other words not strictly speaking inherited by child elements, but this approach is considered preferable to the alternative where the above class would never be pruned due to the static presence of its description child. If instead the class should be kept if any of its children are present, optional children should be explicitly declared as such. The post-processor will evaluate and prune optional elements from the bottom of the hierarchy up, removing any empty optional children from consideration by an optional parent. Lastly, if a class is found to have a mix of empty and populated children, a warning will be issued (currently regardless of whether the populated ones are static as for desrciption above). This is intended to minimise confusion around \"mysteriously missing\" classes when PT is used with a human-in-the-loop (interactive) processor.","title":"\u2023 required"},{"location":"reference/ptl/properties/required/#ptrequired","text":"The required property evaluates to a boolean flag which has similar but distinct consequences depending on whether fetch is in effect. An element whose required property is evaluated to be False is referred to as an optional element, while one whose property is evaluated to True is referred to as a required element.","title":"pt:required"},{"location":"reference/ptl/properties/required/#when-fetching","text":"In the context of a fetch , required is used to determine how to handle missing corresponding source elements. If the property evaluates to True this triggers an error condition, while if it instead evaluates to False the element (subtree) will simply be omitted from the output product. A common usage example of this feature can be seen in the Overview section above.","title":"When fetching"},{"location":"reference/ptl/properties/required/#when-not-fetching","text":"In the non- fetch ing context, required signals whether an element left empty by the product processor (and/or any fill evaluations) should be treated as an error condition (True), or if the element (subtree) should be pruned from the output product (False). Elements that are \"nilled out\", i.e. that contain the attribute xsi:nil=\"true\" , are not considered to be empty by PT. An important detail in this context is that the evaluation of required 's XPath expression is deferred until the post-processing stage. Thus, the expression can inspect the template label as populated by the product processor (which at that point might contain relevant information about what processing has been performed) to determine whether the given element is required to be present in the output label. For example, <img_surface:mesh_id pt:fetch= \"false()\" pt:required= \"//ex:Some_Indicative/ex:attribute == 'meshtype'\" pt:sources= \"template\" /> can be read as: the img_surface:mesh_id attribute will be pruned by the post-processor if it is empty and ex:Some_Indicative/ex:attribute in the output label (conventionally set as the active source via the template source map key) is not equal to \"meshtype\". When a class is evaluated to be optional, then for the purposes of deciding whether it should be pruned, the class is considered empty if any of its children are empty. Therefore, in the case of <emrsp_rm_pan:ISEM_Footprint pt:fetch= \"false()\" pt:required= \"false()\" > <description> Estimated location of the ISEM footprint and 1 sigma radius, based on the focus distance </description> <emrsp_rm_pan:x/> <emrsp_rm_pan:y/> <emrsp_rm_pan:radius/> </emrsp_rm_pan:ISEM_Footprint> the emrsp_rm_pan:ISEM_Footprint class will be pruned by the post-processor if any of x , y or radius is empty. The required property is in other words not strictly speaking inherited by child elements, but this approach is considered preferable to the alternative where the above class would never be pruned due to the static presence of its description child. If instead the class should be kept if any of its children are present, optional children should be explicitly declared as such. The post-processor will evaluate and prune optional elements from the bottom of the hierarchy up, removing any empty optional children from consideration by an optional parent. Lastly, if a class is found to have a mix of empty and populated children, a warning will be issued (currently regardless of whether the populated ones are static as for desrciption above). This is intended to minimise confusion around \"mysteriously missing\" classes when PT is used with a human-in-the-loop (interactive) processor.","title":"When not fetching"},{"location":"reference/ptl/properties/sources/","text":"pt:sources The sources property is used to set the active source label for an element and its descendants. Its expression is used directly as a key to a string -> source label mapping provided by the product processor to PT on instantiation. The resolved active source label acts as the evaluation context of the XPath expressions of other properties, and as the source of fetch es. The sources property must therefore be declared on - or on an ancestor of - any element that declares any other PT properties. Given how the notion of an active source is defined, it is currently not possible to assign property expressions declared on the same element to different source label evaluation contexts. Note, however, that as detailed in a later section the template element is accessible by various means within XPath expressions, regardless of which source is active for an element. Source groups A sources key can map to a sequence of source labels - a \"source group\". In this case, the implied intent is to duplicate the subtree starting from the given element, producing siblings that are each assigned a single label from the source group as their active source. This behaviour is especially useful when fetch ing the same pluralisable class from multiple source products, e.g. in the case of generating derived composite products where the aggregation of certain metadata entries from each source product might be desired. The following example shows the source group functionality used to construct a reference to each input product in the group mapped by the all key. <emrsp_rm:Processing_Inputs pt:fetch= \"false()\" > <emrsp_rm:Processing_Input_Identification pt:sources= \"all\" > <!-- one entry each for all source products --> <emrsp_rm:type> PDS product </emrsp_rm:type> <emrsp_rm:Operational_Reference> <lid_reference/> <emrsp_rm:operational_vid/> </emrsp_rm:Operational_Reference> </emrsp_rm:Processing_Input_Identification> </emrsp_rm:Processing_Inputs> Notice that the cardinality of emrsp_rm:Processing_Input_Identification is determined at runtime by the number of source labels assigned to the all group by the product processor. It is therefore trivial to support derived output products that need to accommodate a variable number of input products.","title":"\u2023 sources"},{"location":"reference/ptl/properties/sources/#ptsources","text":"The sources property is used to set the active source label for an element and its descendants. Its expression is used directly as a key to a string -> source label mapping provided by the product processor to PT on instantiation. The resolved active source label acts as the evaluation context of the XPath expressions of other properties, and as the source of fetch es. The sources property must therefore be declared on - or on an ancestor of - any element that declares any other PT properties. Given how the notion of an active source is defined, it is currently not possible to assign property expressions declared on the same element to different source label evaluation contexts. Note, however, that as detailed in a later section the template element is accessible by various means within XPath expressions, regardless of which source is active for an element.","title":"pt:sources"},{"location":"reference/ptl/properties/sources/#source-groups","text":"A sources key can map to a sequence of source labels - a \"source group\". In this case, the implied intent is to duplicate the subtree starting from the given element, producing siblings that are each assigned a single label from the source group as their active source. This behaviour is especially useful when fetch ing the same pluralisable class from multiple source products, e.g. in the case of generating derived composite products where the aggregation of certain metadata entries from each source product might be desired. The following example shows the source group functionality used to construct a reference to each input product in the group mapped by the all key. <emrsp_rm:Processing_Inputs pt:fetch= \"false()\" > <emrsp_rm:Processing_Input_Identification pt:sources= \"all\" > <!-- one entry each for all source products --> <emrsp_rm:type> PDS product </emrsp_rm:type> <emrsp_rm:Operational_Reference> <lid_reference/> <emrsp_rm:operational_vid/> </emrsp_rm:Operational_Reference> </emrsp_rm:Processing_Input_Identification> </emrsp_rm:Processing_Inputs> Notice that the cardinality of emrsp_rm:Processing_Input_Identification is determined at runtime by the number of source labels assigned to the all group by the product processor. It is therefore trivial to support derived output products that need to accommodate a variable number of input products.","title":"Source groups"}]}